import uuid

from configuration import get_object_configuration_mapper
from elody.util import flatten_dict
from serialization.serialize import serialize


class GenericStorageManager:
    def _does_request_changes(self, item, content, overwrite=False):
        def __is_changed(value, data={}, object_list_key="", is_relation=False):
            if isinstance(value, dict):
                if object_list_key:
                    if data not in item[content_key]:
                        return True
                else:
                    if content_value != item[content_key]:
                        return True
            else:
                if object_list_key:
                    item_value = flat_item.get(
                        f"{content_key}.{data[object_list_key]}.{key}"
                    )
                else:
                    item_value = flat_item.get(content_key)
                if not item_value and value:
                    if is_relation:
                        if flat_content.get(
                            f"{content_key}.{data[object_list_key]}.key"
                        ):
                            return True
                    else:
                        return True
                if item_value and item_value != value:
                    if is_relation:
                        flat_content_value = flat_content.get(
                            f"{content_key}.{data[object_list_key]}.{key}"
                        )
                        if isinstance(flat_content_value, list):
                            flat_content_value = sorted(flat_content_value)
                        if item_value != flat_content_value:
                            return True
                    else:
                        return True

        object_lists = (
            get_object_configuration_mapper()
            .get("none")
            .document_info()
            .get("object_lists", {})
        )
        content = (
            serialize(
                content,
                type=content.get("type"),
                from_format=item.get("schema", {}).get("type", "elody"),
                to_format="elody",
            ),
        )
        item = serialize(item, type=item.get("type"), to_format="elody")
        flat_item = flatten_dict(object_lists, item)
        if isinstance(content, tuple):
            content = content[0]
        flat_content = flatten_dict(object_lists, content)

        for content_key, content_value in content.items():
            if content_key in ["_id", "_key", "id", "identifiers", "storage_format"]:
                continue
            if content_key in object_lists:
                if overwrite and len(content[content_key]) != len(item[content_key]):
                    return True
                for data in content_value:
                    for key, value in data.items():
                        if content_key == "metadata" and key == "key":
                            continue
                        if __is_changed(
                            value,
                            data,
                            object_lists[content_key],
                            is_relation=content_key == "relations",
                        ):
                            return True
            else:
                if __is_changed(content_value):
                    return True

        return False

    def _get_autogenerated_id_for_item(self, item):
        return str(uuid.uuid4())

    def _get_autogenerated_identifiers_for_item(self, item):
        identifiers = set()
        if "identifiers" in item:
            identifiers.update(item["identifiers"])
        for key in ["_id", "_key", "slug", "md5sum"]:
            if key in item:
                identifiers.add(item[key])
        return list(filter(None, identifiers))

    def add_mediafile_to_collection_item(
        self, collection, id, mediafile_id, mediafile_public
    ):
        pass

    def add_mediafile_to_parent(
        self,
        parent_id,
        item_id,
    ):
        pass

    def add_relations_to_collection_item(
        self, collection, id, relations, parent=True, dst_collection=None
    ):
        pass

    def add_sub_item_to_collection_item(self, collection, id, sub_item, content):
        pass

    def check_health(self):
        return True

    def count_relation_items(self, collection, id):
        relations = self.get_collection_item_sub_item(collection, id, "relations")
        return len(relations) if relations else 0

    def delete_collection_item_relations(self, collection, id, content, parent=True):
        pass

    def delete_collection_item_sub_item_key(self, collection, id, sub_item, key):
        sub_items = self.get_collection_item_sub_item(collection, id, sub_item)
        if not sub_items:
            return
        patch_data = {sub_item: []}
        for obj in sub_items:
            if obj["key"] != key:
                patch_data[sub_item].append(obj)
        self.patch_item_from_collection(collection, id, patch_data)

    def delete_item_from_collection(self, collection, id):
        pass

    def get_empty_mediafiles_with_no_relations(self, time=24):
        pass

    def drop_all_collections(self):
        pass

    def get_collection_item_mediafiles(
        self, collection, id, skip=0, limit=0, asc=1, sort="order"
    ):
        pass

    def get_collection_item_relations(
        self, collection, id, include_sub_relations=False, exclude=None
    ):
        pass

    def get_collection_item_sub_item(self, collection, id, sub_item, fallback=None):
        if item := self.get_item_from_collection_by_id(collection, id):
            return item.get(sub_item, fallback)
        return fallback

    def get_collection_item_sub_item_key(self, collection, id, sub_item, key):
        if sub_items := self.get_collection_item_sub_item(collection, id, sub_item):
            return list(filter(lambda x: x["key"] == key, sub_items))
        return None

    def get_entities(
        self,
        skip=0,
        limit=20,
        skip_relations=0,
        filters=None,
        order_by=None,
        ascending=True,
    ):
        pass

    def get_history_for_item(self, collection, id, timestamp=None, all_entries=None):
        pass

    def get_item_from_collection_by_id(self, collection, id) -> dict:
        pass

    def get_item_from_collection_by_metadata(
        self, collection, key, value, type=None
    ) -> dict:
        pass

    def count_items_from_collection(self, collection, fields=None, filters=[]):
        pass

    def get_items_from_collection(
        self,
        collection,
        skip=0,
        limit=20,
        fields=None,
        filters=None,
        sort=None,
        asc=True,
    ):
        pass

    def get_mediafile_linked_entities(self, mediafile):
        pass

    def get_metadata_values_for_collection_item_by_key(self, collection, key):
        pass

    def handle_mediafile_deleted(self, parents):
        pass

    def handle_mediafile_status_change(self, mediafile):
        pass

    def patch_collection_item_metadata(
        self, collection, id, content, ignore_empty_metadata=False
    ):
        metadata = self.get_collection_item_sub_item(collection, id, "metadata")
        if not metadata and not ignore_empty_metadata:
            return None
        if not metadata and ignore_empty_metadata:
            metadata = list()
        for item in content:
            if existing := next(
                (
                    x
                    for x in metadata
                    if x["key"] == item["key"] and x.get("lang") == item.get("lang")
                ),
                None,
            ):
                metadata.remove(existing)
            metadata.append(item)
        return self.patch_item_from_collection(collection, id, {"metadata": metadata})[
            "metadata"
        ]

    def patch_collection_item_relations(self, collection, id, content, parent=True):
        pass

    def patch_item_from_collection(
        self, collection, id, content, create_sortable_metadata=True
    ) -> dict:
        pass

    def reindex_mediafile_parents(self, mediafile=None, parents=None):
        pass

    def save_item_to_collection(
        self,
        collection,
        content,
        only_return_id=False,
        create_sortable_metadata=True,
    ):
        pass

    def set_primary_field_collection_item(self, collection, id, mediafile_id, field):
        pass

    def update_collection_item_relations(self, collection, id, content, parent=True):
        pass

    def update_collection_item_sub_item(self, collection, id, sub_item, content):
        patch_data = {sub_item: content}
        item = self.patch_item_from_collection(collection, id, patch_data)
        return item[sub_item]

    def update_item_from_collection(
        self, collection, id, content, create_sortable_metadata=True
    ):
        pass

    def update_parent_relation_values(self, collection, parent_id):
        pass
